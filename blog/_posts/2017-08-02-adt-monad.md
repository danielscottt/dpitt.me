---
layout: post
title: "An Algebraic Data Type's Monad"
tags:
  - math
  - category theory
---

I watched Dr. Emily Reihl's Compose Conf talk<sup>1</sup> last night and a new intuition emerged.  The purpose of the talk was to explicate the categorical notion of a monad, and while watching it, I was struck with the realization of how a monad arises from an algebraic data type.

## Prereqs

In her talk, she first discusses `T` as a computation, and defines a `T` as a monad: something that can take an `A` and lift it to a `T(A)`, like this:

<pre>
A &rarr; T(A)
</pre>

_NB: There is another operation that comes with a monad, `extend`, but we'll skip that for now._

The canonical example used through the first half of the talk is a `List`: A function from <code>A &rarr; T(A)</code> could be a function from an `A` to a `List` of `A`'s where `T` is the _computation_ which constructs a list of `A`'s. That is, <code>A &rarr; T(A)</code> is simply a more general version of <code>A &rarr; List(A)</code>.

She goes on to use the notation of <code>&#8605;</code> to denote a "program" which contains one of these lift operations, but with <code>&#8605;</code>, we elide the `T`:
<pre>
A &rarr; T(B) = A &#8605; B
</pre>

## An ADT Monad

Later in the talk, she defines a function from `A` to <code>A + {&#8869;}</code>:
<pre>
A &rarr; A + {&#8869;}
</pre>
This should look familiar — it contains a `+` after all! It's an algebraic data type — a sum type to be specfic. It can give us either an `A` or <code>&#8869;</code>; <code>&#8869;</code> means "bottom" or `false` in this context.  It would look something like this in Haskell:
{% highlight haskell %}
data Maybe a = Nothing | Just a

f :: a -> Maybe a
{% endhighlight %}
And as we know, `Maybe` emits a monad where if we have an `a`, we apply our lift to it to get a `Just a`. In Haskell, this lift is called `return`, and made available in the Monad typeclass:

{% highlight haskell %}
return :: Monad m => a -> m a
{% endhighlight %}

Which, if we squint, looks an awful lot like `A -> T(A)`.  For edification purposes, our definition of `return` for `Maybe` and the other requisite pieces of a Monad in Haskell are below.

{% highlight haskell %}
instance Monad Maybe where
  return = Just
  (Just x) >>= f = f x
  Nothing >>= _ = Nothing
{% endhighlight %}

If you're still squinting, you can start to see how:

* Our ADT becomes `T`, the _computation_ which can give us either our `A`, or `Nothing`
* We could denote `f` as <code>f: A &#8605; A</code>.

---
1. [A Categorical View of Computational Effects](https://www.youtube.com/watch?v=6t6bsWVOIzs)

{% include stats.html %}
